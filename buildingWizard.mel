/* Building wizard */
/* created by RJ. 2016 */


/* Edge length calculator */
global proc float edgeLength(float $ptX1, float $ptZ1, float $ptX2, float $ptZ2) {
    float $edgeLength = 0;
    $edgeLength = sqrt(($ptX2 - $ptX1)*($ptX2 - $ptX1) + ($ptZ2 - $ptZ1)*($ptZ2 - $ptZ1));
    return $edgeLength;    
}

// ************************************************************************************************ //

/* Curve Spans Length */

proc float[] curveSpansLength(string $curve){
    
    int $i=0;
    int $nCV = 1;
    int $nSpans = `getAttr ($curve + ".spans")`;
    // Counting number of CVs
    select -r ($curve + ".cv[0]");
    string $cvSel[];
    for ($i=0; $nCV < ($nSpans+3); $i++){
        $cvSel = `pickWalk -d "Left"`;
        if ($cvSel[0] != ($curve + ".cv[0]")){
            $nCV++;
        } else {
            break;
        }
    }
    print ("\nCurve has " + $nCV + " CVs");
    print ("\nCurve has " + $nSpans + " Spans");
    // Calculating the perimeter length
    float $perimeter = `arclen $curve`;
    // Length for each wall
    float $spansLength[];
    if ($nCV == $nSpans){
        for ($i=0; $i<$nCV; $i++){
            if ($i == ($nCV-1)){
                float $cvPos_A[] = `pointPosition ($curve + ".cv[" + $i + "]")`;
                float $cvPos_B[] = `pointPosition ($curve + ".cv[0]")`;
                $spansLength[$i] = sqrt(($cvPos_B[0] - $cvPos_A[0])*($cvPos_B[0] - $cvPos_A[0]) + (($cvPos_B[2] - $cvPos_A[2])*($cvPos_B[2] - $cvPos_A[2])));
            } else {
                float $cvPos_A[] = `pointPosition ($curve + ".cv[" + $i + "]")`;
                float $cvPos_B[] = `pointPosition ($curve + ".cv[" + ($i + 1) + "]")`;
                $spansLength[$i] = sqrt(($cvPos_B[0] - $cvPos_A[0])*($cvPos_B[0] - $cvPos_A[0]) + (($cvPos_B[2] - $cvPos_A[2])*($cvPos_B[2] - $cvPos_A[2])));
            }
        }
    } else {
        for ($i=0; $i<($nCV-1); $i++){
            float $cvPos_A[] = `pointPosition ($curve + ".cv[" + $i + "]")`;
            float $cvPos_B[] = `pointPosition ($curve + ".cv[" + ($i + 1) + "]")`;
            $spansLength[$i] = sqrt(($cvPos_B[0] - $cvPos_A[0])*($cvPos_B[0] - $cvPos_A[0]) + (($cvPos_B[2] - $cvPos_A[2])*($cvPos_B[2] - $cvPos_A[2])));
        }
    }
    return $spansLength;
}

// ************************************************************************************************ //

/* Instance at selected Locators tool */
proc instAtLocators(string $locators[], string $obj, string $lvl) {
    int $j = 0;
    // Instancing object
    for ($j = 0; $j < size($locators); $j++) {
        string $name = ($lvl + "_" + $obj + "_0" + $j);
        instance -n $name $obj;
        string $PtCnst = "tempConstr";
        parentConstraint -n $PtCnst $locators[$j] $name;
        delete $PtCnst;       
    }
}

// ************************************************************************************************ //

/* Random 90 degrees angle generation */
global proc float rand90Rotation(){
    float $rotValue = rand(0,360);
    if ($rotValue <= 90 && $rotValue > 0) {
        $rotValue = 90;
    } else if ($rotValue <= 180 && $rotValue > 90) {
        $rotValue = 180;
    } else if ($rotValue <= 270 && $rotValue > 180) {
        $rotValue = 270;
    } else {
        $rotValue = 0;
    }
    return $rotValue;
}

// ************************************************************************************************ //

/* Walls generator */
proc wallsGen(string $curveShape, float $locFloorHeight, string $lvl){
    // Quering a number of points inside curve shape
    int $nVerts = `getAttr ($curveShape + ".spans")`;
    
    int $i = 0;
    string $vtxList[];
    
    // Storing all the points under an array variable
    for ($i = 0; $i<$nVerts; $i++){
        $vtxList[$i] = ($curveShape + ".cv[" + $i + "]");
    }
    
    // Storing an 'X' coordinates of all the points under an array
    float $xCoords[];
    for ($i=0; $i < $nVerts; $i++){
        float $vtxCoord[] = `pointPosition $vtxList[$i]`;
        $xCoords[$i] = $vtxCoord[0];
    }
    
    // Storing an 'Z' coordinates of all the points under an array
    float $zCoords[];
    for ($i=0; $i < $nVerts; $i++){
        float $vtxCoord[] = `pointPosition $vtxList[$i]`;
        $zCoords[$i] = $vtxCoord[2];
    }
    
    // Creating commands for generating the walls
    string $wallPoly[];
    for ($i=0; $i<$nVerts; $i++){
        if ($i < ($nVerts - 1)){
            $wallPoly[$i] = ("polyCreateFacet -tx 1 -p " + $xCoords[$i] + " " + 0 + " " + $zCoords[$i] + " -p " + $xCoords[$i+1] + " " + 0 + " " + $zCoords[$i+1] + " -p " + $xCoords[$i+1] + " " + $locFloorHeight + " " + $zCoords[$i+1] + " -p " + $xCoords[$i] + " " + $locFloorHeight + " " + $zCoords[$i] + " -n " + $lvl + "_wall_0" + $i + ";");
        } else {
            $wallPoly[$i] = ("polyCreateFacet -tx 1 -p " + $xCoords[$i] + " " + 0 + " " + $zCoords[$i] + " -p " + $xCoords[0] + " " + 0 + " " + $zCoords[0] + " -p " + $xCoords[0] + " " + $locFloorHeight + " " + $zCoords[0] + " -p " + $xCoords[$i] + " " + $locFloorHeight + " " + $zCoords[$i] + " -n " + $lvl + "_wall_0" + $i + ";");
        }
    }

    // Generating
    string $walls[];
    for ($i=0; $i<$nVerts; $i++){
        eval ($wallPoly[$i]);
        $walls[$i] = ($lvl + "_wall_" + "0" + $i);
    }
    
    // Combining the walls under one mesh
    select -cl;
    for ($wall in $walls){
        select -add $wall;
    }
    polyUnite -ch 0 -mergeUVSets 1 -centerPivot -n ($lvl + "_wall_" + "01");
}

// ************************************************************************************************ //

/* Windows placement */

proc windowPlacement(string $shapeCurve, float $groundFloorHeight, float $floorHeight, float $horPag, float $vertPag, float $winWidth, float $winHeight, float $winDepth, string $lvl){
    
    int $i = 0;
    int $nVerts = `getAttr ($shapeCurve + ".spans")`;
    // Calculating the perimeter length
    float $perimeter = `arclen $shapeCurve`;
    // Length for each wall
    float $wallsLength[];
    
    for ($i=0; $i<$nVerts; $i++){
        float $cvPos_A[] = `pointPosition ($shapeCurve + ".cv[" + $i + "]")`;
        float $cvPos_B[] = `pointPosition ($shapeCurve + ".cv[" + ($i + 1) + "]")`;
        $wallsLength[$i] = edgeLength($cvPos_A[0], $cvPos_A[2], $cvPos_B[0], $cvPos_B[2]);
    }
    
    // Calculating how much windows can be placed onto each wall
    float $windowsSpace[];
    int $windowsNum[];
    
    for ($i=0; $i<$nVerts; $i++){
        $windowsSpace[$i] = $wallsLength[$i] - ($horPag*2);
        $windowsNum[$i] = ($windowsSpace[$i]/$winWidth);
    }
    
    // Finding out a position on the curve of each possible window
    for ($i=0; $i<$nVerts; $i++){
        int $k=0;
        float $distUpToThePoint = 0;
        for ($k=0; $k<($i); $k++){
            $distUpToThePoint += $wallsLength[$k];
        }
        print ("wall " + $i + " summary length is:\n" + $distUpToThePoint + "\n"); 
        float $step = 1/$perimeter;
        for ($k=0; $k<$windowsNum[$i]; $k++){
            float $winLocation = ($distUpToThePoint + $horPag + ($k*$winWidth) + ($winWidth/2) + ($wallsLength[$i] - $horPag*2 - $winWidth*$windowsNum[$i])/2)*$step;
            string $loc[] = `spaceLocator -n "loc_window1"`;
            string $moPath = `pathAnimation -fractionMode true -follow true -followAxis x -upAxis y -worldUpType "vector" -worldUpVector 0 1 0 -inverseUp false -inverseFront true -bank false -startTimeU 1 -endTimeU 2 $loc[0] $shapeCurve`;
            CBdeleteConnection ($moPath + ".u");
            setAttr ($moPath + ".u") $winLocation;
            
            CBdeleteConnection ($loc[0] + ".tx");
            CBdeleteConnection ($loc[0] + ".ty");
            CBdeleteConnection ($loc[0] + ".tz");
            CBdeleteConnection ($loc[0] + ".rx");
            CBdeleteConnection ($loc[0] + ".ry");
            CBdeleteConnection ($loc[0] + ".rz");
            
            move -r 0 $vertPag 0 $loc[0];
        }
    }
}

// ************************************************************************************************ //
/* Clonning Window BBoxes onto windows' positions */
proc bboxPlacement(string $window, string $BBox, string $lvl){
    if ($BBox != "_"){
        string $windows[] = `ls -tr ($lvl + "_" + $window + "*")`;
        int $i=0;
            for ($i=0; $i<(size($windows)); $i++){
                string $tempSel[] = `duplicate -n ($lvl + "_" + $BBox) $BBox`;
                parentConstraint $windows[$i] $tempSel[0];
            }
    } else {
        print "Window's form is standard";
    }
}

// ************************************************************************************************ //

/* Windows Cut Out*/

proc windowsCutOut(string $wallPrefix, string $windowPrefix, float $depth, string $winBBoxPrefix, string $lvl){
    
    // Storing the wall under a variable
    string $wall[] = `ls -tr ($wallPrefix + "*")`;
    string $wallCopy[] = `duplicate -n ($wall[0] + "_copy") $wall[0]`;
    select -r ($windowPrefix + "*");
    string $windowsSel[] = `ls -sl -tr`; select -cl;
    string $winBBox[];
    // Removing constraints from BBoxes
    string $ptCnst[] = `ls "*parentConstraint*"`;
    if (`objExists $ptCnst[0]`){delete "*parentConstraint*";}
    // Creating BBoxes
    if ($winBBoxPrefix != "_"){
        $winBBox = `ls -tr ($lvl + "_" + $winBBoxPrefix + "*")`;
        print $winBBox;
        for ($box in $winBBox){
            move -r -os 0 0 $depth $box;
            scale -r -1 1 ($depth/3) $box;
        }
    } else {
        // Select all level windows
        for ($win in $windowsSel){
            duplicate -n ($win + "_copy") $win;
            geomToBBox -nameSuffix _BBox -shaderColor 0.5 0.5 0.5 ($win + "_copy");
            move -r -os 0 0 $depth;
            scale -r -1 1 $depth;
            
            select -r $win; move -r -os 0 0 ($depth -1); select -cl;
        }
    }
    // Generating a 'combination' command
    if ($winBBoxPrefix != "_"){
        int $i=0;
        string $combineCmd = "polyUnite -ch 0 -mergeUVSets 1 -name tempGeo";
        for ($i=0; $i<(size($winBBox)); $i++){
            $combineCmd = $combineCmd + (" " + $winBBox[$i]);
        }
        print "\n"; print $winBBox;
        $combineCmd = ($combineCmd + ";");
        print ("\n" + $combineCmd);
        eval($combineCmd); //delete -ch "tempGeo";
        print ("\n" + $wall[0]);
        polyCBoolOp -op 2 -ch 0 -preserveColor 0 -classification 1 -name ($wall[0] + "_cutOut") $wallCopy[0] "tempGeo";
        hide $wall[0];
    } else {
        int $i=0;
        string $combineCmd = "polyUnite -ch 0 -mergeUVSets 1 -name tempGeo";
        for ($i=0; $i<(size($windowsSel)); $i++){
            $combineCmd = $combineCmd + (" " + $windowsSel[$i] + "_copy_BBox");
        }
        $combineCmd = ($combineCmd + ";");
        print ("\n" + $combineCmd);
        eval($combineCmd);
        print ("\n" + $wall[0]);
        polyCBoolOp -op 2 -ch 0 -preserveColor 0 -classification 1 -name ($wall[0] + "_cutOut") $wallCopy[0] "tempGeo";
        hide $wall[0];        
    }
    select -r ($windowPrefix + "*"); move -r -os 0 0 $depth; select -cl;
}

// ************************************************************************************************ //

/* Corner column instancing */

proc cornerColumnsInst(string $curveShape, string $cornerColumn, string $lvl){
    // Quering a number of points inside curve shape
    int $nVerts = `getAttr ($curveShape + ".spans")`;
    
    int $i = 0;
    string $vtxList[];
    
    // Storing all the points under an array variable
    for ($i = 0; $i<$nVerts; $i++){
        $vtxList[$i] = ($curveShape + ".cv[" + $i + "]");
    }
    
    // Storing an 'X' coordinates of all the points under an array
    float $xCoords[];
    for ($i=0; $i < $nVerts; $i++){
        float $vtxCoord[] = `pointPosition $vtxList[$i]`;
        $xCoords[$i] = $vtxCoord[0];
    }
    
    // Storing an 'Z' coordinates of all the points under an array
    float $zCoords[];
    for ($i=0; $i < $nVerts; $i++){
        float $vtxCoord[] = `pointPosition $vtxList[$i]`;
        $zCoords[$i] = $vtxCoord[2];
    }

    // Generating
    for ($i=0; $i<$nVerts; $i++){
        string $tempsSel[] = `instance -n ($lvl + "_cornerColumn_0" + $i) $cornerColumn`;
        move -ws $xCoords[$i] 0 $zCoords[$i] $tempsSel[0];
    }
}    

// ************************************************************************************************ //

/* Reinforcements Placement */

proc reinforcementsPlacement(string $distribution, string $lvl, string $perimeterObj, string $reinforcementObj, string $windowObj, int $unitsInCluster, int $clustersNum, float $unitWidth, float $clusterInterval){
    int $i = 0;
    int $wallsNum = `getAttr ($perimeterObj + ".spans")`;
    // Perimeter length
    float $perimeter = `arclen $perimeterObj`;
    // Length for each wall
    float $wallsLength[] = `curveSpansLength($perimeterObj)`;
    // Width for a reinforcements cluster
    float $clusterWidth = ($unitsInCluster * $unitWidth) + $clusterInterval;
    // Calculating how many clusters cam be fit inside each wall
    int $clustersInWall[];
    for ($i=0; $i<$wallsNum; $i++){
        $clustersInWall[$i] = ($wallsLength[$i]/($unitWidth + $clusterInterval));
    }
    print ("\nClusters in wall:\n"); print $clustersInWall;
    // Translating metric units into 'steps' relative to the curve's length
    float $step = 1/$perimeter;
    // Looking for a position of the perimeter curve for each possible cluster
    // If distribution is set to 'Even'
    if ($distribution == "even"){
        for ($i=0; $i<$wallsNum; $i++){
            int $k=0;
            float $distUpToThePoint = 0;
            for ($k=0; $k<($i); $k++){
                $distUpToThePoint += $wallsLength[$k];
            }
            print ("wall " + $i + " summary length is:\n" + $distUpToThePoint + "\n"); 
            for ($k=0; $k<$clustersInWall[$i]; $k++){
                float $clusterLocation = ($distUpToThePoint + ($k*$clusterWidth) + ($clusterWidth/2) + ($wallsLength[$i] - $clusterWidth*$clustersInWall[$i])/2)*$step;
                print ("\nNew Cluster Location is: " + $clusterLocation);
                string $loc[] = `spaceLocator -n "loc_reinforcementCluster1"`;
                string $moPath = `pathAnimation -fractionMode true -follow true -followAxis x -upAxis y -worldUpType "vector" -worldUpVector 0 1 0 -inverseUp false -inverseFront true -bank false -startTimeU 1 -endTimeU 2 $loc[0] $perimeterObj`;
                CBdeleteConnection ($moPath + ".u");
                setAttr ($moPath + ".u") $clusterLocation;
                
                CBdeleteConnection ($loc[0] + ".tx");
                CBdeleteConnection ($loc[0] + ".ty");
                CBdeleteConnection ($loc[0] + ".tz");
                CBdeleteConnection ($loc[0] + ".rx");
                CBdeleteConnection ($loc[0] + ".ry");
                CBdeleteConnection ($loc[0] + ".rz");
                
                delete $moPath;
            }
        }
    } else if ($distribution == "between windows"){
        select -r ($lvl + "_" + $windowObj + "*");
        string $winSel[] = `ls -sl -tr`;
        for ($i=0; $i<(size($winSel)-1); $i++){
            float $winPosX_A = `getAttr ($winSel[$i] + ".tx")`;
            float $winPosZ_A = `getAttr ($winSel[$i] + ".tz")`;
            float $winPosX_B = `getAttr ($winSel[$i+1] + ".tx")`;
            float $winPosZ_B = `getAttr ($winSel[$i+1] + ".tz")`;
            float $winRotY_A = `getAttr ($winSel[$i] + ".ry")`;
            float $winRotY_B = `getAttr ($winSel[$i+1] + ".ry")`;
            if ($winRotY_A == $winRotY_B) {
                float $locPosX = ($winPosX_A + $winPosX_B)/2;
                float $locPosZ = ($winPosZ_A + $winPosZ_B)/2;
                print ("\nNew Cluster Location is: " + $locPosX + " and " + $locPosZ);
                string $loc[] = `spaceLocator -n "loc_reinforcementCluster1"`;
                setAttr ($loc[0] + ".tx") $locPosX;
                setAttr ($loc[0] + ".tz") $locPosZ;
                setAttr ($loc[0] + ".ry") $winRotY_A;
            }
        }
    } else if ($distribution == "middle"){
        for ($i=0; $i<$wallsNum; $i++){
            int $k=0;
            float $distUpToThePoint = 0;
            for ($k=0; $k<($i); $k++){
                $distUpToThePoint += $wallsLength[$k];
            }
            print ("wall " + $i + " summary length is:\n" + $distUpToThePoint + "\n"); 
            
            float $clusterLocation = ($distUpToThePoint + ($wallsLength[$i]/2))*$step;
            print ("\nNew Cluster Location is: " + $clusterLocation);
            string $loc[] = `spaceLocator -n "loc_reinforcementCluster1"`;
            string $moPath = `pathAnimation -fractionMode true -follow true -followAxis x -upAxis y -worldUpType "vector" -worldUpVector 0 1 0 -inverseUp false -inverseFront true -bank false -startTimeU 1 -endTimeU 2 $loc[0] $perimeterObj`;
            CBdeleteConnection ($moPath + ".u");
            setAttr ($moPath + ".u") $clusterLocation;
            
            CBdeleteConnection ($loc[0] + ".tx");
            CBdeleteConnection ($loc[0] + ".ty");
            CBdeleteConnection ($loc[0] + ".tz");
            CBdeleteConnection ($loc[0] + ".rx");
            CBdeleteConnection ($loc[0] + ".ry");
            CBdeleteConnection ($loc[0] + ".rz");
            
            delete $moPath;
        }
    }
}

// ************************************************************************************************ //

/* Eaves Generation */

proc extrudeEaves(string $perimeterShape, string $eavesProfile, string $lvl) {
          
    string $profile[] = `instance $eavesProfile`; 
    string $curve[] = `duplicate $perimeterShape`;
    closeCurve -ch 0 -ps 1 -rpo 1 -bb 0.5 -bki 0 -p 0.1 $curve[0];
    
    string $movePath = `pathAnimation -follow true -followAxis y -upAxis z -worldUpType "vector" -worldUpVector 0 1 0 -c $curve[0] $profile[0]`;
    string $extrude[] = `extrude -ch true -rn false -po 0 -et 2 -ucp 1 -fpt 1 -upn 1 -rotation 0 -scale 1 -rsp 1 $profile[0] $curve[0]`;
    
    string $polyEaves[] = `nurbsToPoly -mnd 1 -ch 0 -f 3 -pt 0 -pc 200 -chr 0.9 -ft 0.01 -mel 0.001 -d 0.1 -ut 1 -un 3 -vt 1 -vn 3 -uch 0 -ucr 0 -cht 0.2 -es 0 -ntr 0 -mrt 0 -uss 1 -name ($lvl + "_eaves00") $extrude[0]`;
    polySoftEdge -a 0 -ch 0 $polyEaves[0];
    
    delete $movePath $curve[0] $profile[0] $extrude[0];
}

// ************************************************************************************************ //

/* Floor instancing */

proc instanceLevel(string $levelName, float $lvlHeight, int $lvlNum){
    int $i = 0;
    for ($i=1; $i < $lvlNum; $i++){
        string $newGrp = `group -em -n ("grp_" + $levelName)`;
        select -r ("grp_" + $levelName + " | " + $levelName + "*");
        string $lvlParts[] = `ls -sl -tr`;
        for ($part in $lvlParts){
            string $instPart[] = `instance $part`;
            parent $instPart[0] $newGrp;
        }
        select -cl;
        move -ws 0 ($lvlHeight * $i) 0 $newGrp;
    }
}

// ************************************************************************************************ //

/* Create Roof */

proc roofGen(string $perimeter, float $levelHeight, int $levelsNum, string $lvl){
    // Quering a number of points inside curve shape
    int $nVerts = `getAttr ($perimeter + ".spans")`;

    int $i = 0;
    string $vtxList[];
    // Storing all the points under an array variable
    for ($i = 0; $i<$nVerts; $i++){
        $vtxList[$i] = ($perimeter + ".cv[" + $i + "]");
    }
    // Storing an 'X' coordinates of all the points under an array
    float $xCoords[];
    for ($i=0; $i < $nVerts; $i++){
        float $vtxCoord[] = `pointPosition $vtxList[$i]`;
        $xCoords[$i] = $vtxCoord[0];
    }
    // Storing an 'Z' coordinates of all the points under an array
    float $zCoords[];
    for ($i=0; $i < $nVerts; $i++){
        float $vtxCoord[] = `pointPosition $vtxList[$i]`;
        $zCoords[$i] = $vtxCoord[2];
    }
    // Storing an 'Y' coordinate
    float $yCoord = $levelHeight*$levelsNum;
    // Creating commands for generating the roof
    string $roofCommand = "polyCreateFacet -tx 1";
    for ($i=0; $i<$nVerts; $i++){
        $roofCommand = ($roofCommand + " -p " + $xCoords[$i] + " " + $yCoord + " " + $zCoords[$i]);
    }
    $roofCommand = ($roofCommand + " -n " + $lvl + "_roof_0;");
    print ("\n" + $roofCommand);
    eval($roofCommand);
}

// ************************************************************************************************ //

/* Roof Set Dressing */

proc roofSetDressing(string $antenna, string $roofAC, string $roofExit, int $railing, float $railingHeight, float $railingThickness, string $lvl, float $edgePag){
    // Naming the roof
    string $roofObj = $lvl + "_roof_0";
    // Query roof's height
    float $roofHeight[] = `pointPosition ($roofObj + ".vtx[0]")`;
    // Find out the closest 4 points to the XZ-origin
    float $closestPosX = 50000;
    float $closestPosZ = 50000;
    float $closestNegX = -50000;
    float $closestNegZ = -50000;
    
    int $vtxCount[] = `polyEvaluate -v $roofObj`;
    print ("\n" + $vtxCount[0] + "\n");
    // Comparing the point's X and Z values to find out closest positive and negative values
    int $i=0;
    for ($i=0; $i<$vtxCount[0]; $i++){
        float $vtxCoords[] = `pointPosition ($roofObj + ".vtx[" + $i + "]")`;
        // Looking for 'closest positive' X
        if ($vtxCoords[0] > 0 && $vtxCoords[0] < $closestPosX){
            $closestPosX = $vtxCoords[0];
        }
        // Looking for 'closest negative' X
        if ($vtxCoords[0] < 0 && $vtxCoords[0] > $closestNegX){
            $closestNegX = $vtxCoords[0];
        }
        // Looking for 'closest positive' Z
        if ($vtxCoords[2] > 0 && $vtxCoords[2] < $closestPosZ){
            $closestPosZ = $vtxCoords[2];
        }
        // Looking for 'closest negative' Z
        if ($vtxCoords[2] < 0 && $vtxCoords[2] > $closestNegZ){
            $closestNegZ = $vtxCoords[2];
        }        
    }
    
    // Placing Roof Exit
    if ($roofExit != "No Roof Exit!") {
        string $tempString[] = `instance $roofExit`;
        float $rotValue = `rand90Rotation`;
        float $moveX = rand(($closestNegX + $edgePag), ($closestPosX - $edgePag));
        float $moveZ = rand(($closestNegZ + $edgePag), ($closestPosZ - $edgePag));
        move -ws -a $moveX $roofHeight[1] $moveZ $tempString[0]; 
        rotate -ws -a 0 $rotValue 0 $tempString[0];
    } else { print ("\n" + $roofExit + "\n"); }
    
    // Placing Roof Exit
    if ($roofAC != "No Roof AC!") {
        string $tempString[] = `instance $roofAC`;
        float $rotValue = `rand90Rotation`;
        float $moveX = rand(($closestNegX + $edgePag), ($closestPosX - $edgePag));
        float $moveZ = rand(($closestNegZ + $edgePag), ($closestPosZ - $edgePag));
        move -ws -a $moveX $roofHeight[1] $moveZ $tempString[0]; 
        rotate -ws -a 0 $rotValue 0 $tempString[0];
    } else { print ("\n" + $roofAC + "\n"); }
    
    // Placing antennas
    if ($antenna != "No Antennas!") {
        string $tempString[] = `instance $antenna`;
        float $rotValue = `rand90Rotation`;
        float $moveX = rand(($closestNegX + $edgePag), ($closestPosX - $edgePag));
        float $moveZ = rand(($closestNegZ + $edgePag), ($closestPosZ - $edgePag));
        move -ws -a $moveX $roofHeight[1] $moveZ $tempString[0]; 
        rotate -ws -a 0 $rotValue 0 $tempString[0];
    } else { print ("\n" + $antenna + "\n"); }

    // Generating railing
    if ($railing != 0) {
        string $vtxList[];
        // Storing all the points under an array variable
        for ($i = 0; $i<$vtxCount[0]; $i++){
            $vtxList[$i] = ($roofObj + ".vtx[" + $i + "]");
        }
        // Storing an 'X' coordinates of all the points under an array
        float $xCoords[];
        for ($i=0; $i < $vtxCount[0]; $i++){
            float $vtxCoord[] = `pointPosition $vtxList[$i]`;
            $xCoords[$i] = $vtxCoord[0];
        }
        // Storing an 'Z' coordinates of all the points under an array
        float $zCoords[];
        for ($i=0; $i < $vtxCount[0]; $i++){
            float $vtxCoord[] = `pointPosition $vtxList[$i]`;
            $zCoords[$i] = $vtxCoord[2];
        }
        // Creating commands for generating the walls
        string $railingPoly[];
        for ($i=0; $i<$vtxCount[0]; $i++){
            if ($i < ($vtxCount[0] - 1)){
                $railingPoly[$i] = ("polyCreateFacet -tx 1 -p " + $xCoords[$i] + " " + $roofHeight[1] + " " + $zCoords[$i] + " -p " + $xCoords[$i+1] + " " + $roofHeight[1] + " " + $zCoords[$i+1] + " -p " + $xCoords[$i+1] + " " + ($railingHeight + $roofHeight[1]) + " " + $zCoords[$i+1] + " -p " + $xCoords[$i] + " " + ($railingHeight + $roofHeight[1]) + " " + $zCoords[$i] + " -n " + "roofRailing_" + "0" + $i + ";");
            } else {
                $railingPoly[$i] = ("polyCreateFacet -tx 1 -p " + $xCoords[$i] + " " + $roofHeight[1] + " " + $zCoords[$i] + " -p " + $xCoords[0] + " " + $roofHeight[1] + " " + $zCoords[0] + " -p " + $xCoords[0] + " " + ($railingHeight + $roofHeight[1]) + " " + $zCoords[0] + " -p " + $xCoords[$i] + " " + ($railingHeight + $roofHeight[1]) + " " + $zCoords[$i] + " -n " + "roofRailing_" + "0" + $i + ";");
            }
        }
        // Generating
        string $railings[];
        for ($i=0; $i<$vtxCount[0]; $i++){
            eval ($railingPoly[$i]);
            $railings[$i] = ("roofRailing_" + "0" + $i);
        }
        // Combining the railings under one mesh
        select -cl;
        for ($rail in $railings){
            select -add $rail;
        }
        string $railingObj[] = `polyUnite -ch 0 -mergeUVSets 1 -centerPivot -n ($lvl + "_roofRailings_01")`;
        // Adding thickness to the railings
        int $faceCount[] = `polyEvaluate -f $railingObj[0]`;
        polyExtrudeFacet -ch 0 -keepFacesTogether 1 -pvx 250 -pvy 2400 -pvz -250 -divisions 1 -twist 0 -taper 1 -off 0 -thickness -20 -smoothingAngle 30 ($railingObj[0] + ".f[0:" + $faceCount[0] + "]");
        select -r $railingObj[0];
        ReversePolygonNormals;
    } else { print ("\n" + "No Roof Railing!" + "\n"); }
}

// ************************************************************************************************ //

/* Fire Excape Ladder Generation */

proc fireEscapeLadder(string $lvl, int $lvlNum, string $window, float $lvlHeight, int $sectionsPerLvl, float $stepDepth, float $stepWidth, float $stepHeight){
    
    // Creating steps
    int $section = 1;
    float $sectionHeight = $lvlHeight/$sectionsPerLvl;
    int $sectionsNum = $lvlNum * $sectionsPerLvl;
    int $stepsPerSection = $sectionHeight/$stepHeight;
    int $i=0;
    // Creating a step objects

    string $step[] = `polyCube -ch 0 -w $stepWidth -h 4 -d $stepDepth -n "fireEscape_step"`;
    for ($section = 0; $section < $sectionsNum; $section++){
        // Differenciating between 'odd' and 'even' sections
        if ($section%2 != 0){
            for ($i=0; $i<$stepsPerSection; $i++){
                float $stepXPos = $stepWidth/2;
                float $stepYPos = $stepHeight*$i + ($section * $sectionHeight);
                float $stepZPos = $stepDepth*$i;
                if ($i == 0) {
                    string $stepInst[] = `instance -n ("inst_" + $step[0]) $step[0]`;
                    move -r -os $stepXPos $stepYPos ($stepZPos - (5 * $stepDepth)) $stepInst[0];
                    scale 1 1 11 $stepInst[0];
                } else if ($i == ($stepsPerSection - 1)){
                    string $stepInst[] = `instance -n ("inst_" + $step[0]) $step[0]`;
                    move -r -os $stepXPos $stepYPos ($stepZPos + (2 * $stepDepth)) $stepInst[0];
                    scale 1 1 5 $stepInst[0];
                } else {
                    string $stepInst[] = `instance -n ("inst_" + $step[0]) $step[0]`;
                    move -r -os $stepXPos $stepYPos $stepZPos $stepInst[0];
                }
            }
        } else {
            for ($i=0; $i<$stepsPerSection; $i++){
                float $stepXPos = (-1) * $stepWidth/2;
                float $stepYPos = $stepHeight*$i + ($section * $sectionHeight);
                float $stepZPos = $stepDepth*$i*(-1);
                if ($i == 0) {
                    string $stepInst[] = `instance -n ("inst_" + $step[0]) $step[0]`;
                    move -r -os $stepXPos $stepYPos ($stepZPos + (5 * $stepDepth)) $stepInst[0];
                    scale 1 1 11 $stepInst[0];
                } else if ($i == ($stepsPerSection - 1)){
                    string $stepInst[] = `instance -n ("inst_" + $step[0]) $step[0]`;
                    move -r -os $stepXPos $stepYPos ($stepZPos - (2 * $stepDepth)) $stepInst[0];
                    scale 1 1 5 $stepInst[0];
                } else {
                    string $stepInst[] = `instance -n ("inst_" + $step[0]) $step[0]`;
                    move -r -os $stepXPos $stepYPos $stepZPos $stepInst[0];
                }
            }
        }  
    }
    delete $step[0];
    // Creating columns
    string $column[] = `polyCube -ch 0 -w 15 -h ($lvlHeight * $lvlNum) -d 15 -n "fireEscape_column"`;
    // Calculating locations of the columns
    float $colYLoc = ($lvlHeight * $lvlNum)/2;
    float $colXNegLoc = $stepWidth*(-1);
    float $colXPosLoc = $stepWidth;
    float $colXMidLoc = 0;
    float $colZNegLoc = $stepDepth*(-10.5);
    float $colZPosLoc = $stepDepth*10.5;
    float $colZMidLoc = 0;
    // Instancing columns into positions
    instance -n ($column[0] + "_A") $column[0]; move $colXNegLoc $colYLoc $colZNegLoc ($column[0] + "_A");
    instance -n ($column[0] + "_B") $column[0]; move $colXMidLoc $colYLoc $colZNegLoc ($column[0] + "_B");
    instance -n ($column[0] + "_C") $column[0]; move $colXPosLoc $colYLoc $colZNegLoc ($column[0] + "_C");
    instance -n ($column[0] + "_D") $column[0]; move $colXPosLoc $colYLoc $colZMidLoc ($column[0] + "_D");
    instance -n ($column[0] + "_E") $column[0]; move $colXPosLoc $colYLoc $colZPosLoc ($column[0] + "_E");
    instance -n ($column[0] + "_F") $column[0]; move $colXMidLoc $colYLoc $colZPosLoc ($column[0] + "_F");
    instance -n ($column[0] + "_G") $column[0]; move $colXNegLoc $colYLoc $colZPosLoc ($column[0] + "_G");
    delete $column[0];
    //Creating railing
    float $railvertStep = 80;
    string $frontRail[] = `polyCube -ch 0 -d ($stepDepth*21) -w 8 -h 6 -n "fireEscape_frontRail"`;
    string $sideRailA[] = `polyCube -ch 0 -d 8 -w ($stepWidth*2) -h 6 -n "fireEscape_sideRail_A"`;
    string $sideRailB[] = `polyCube -ch 0 -d 8 -w ($stepWidth*2) -h 6 -n "fireEscape_sideRail_B"`;
    
    for ($i=1; $i<(($lvlHeight * $lvlNum)/$railvertStep); $i++){
        string $railYLoc = $railvertStep * $i;
        instance -n ("inst_" + $frontRail[0] + "_" + $i) $frontRail[0]; move $colXPosLoc $railYLoc 0 ("inst_" + $frontRail[0] + "_" + $i);
        instance -n ("inst_" + $sideRailA[0] + "_" + $i) $sideRailA[0]; move 0 $railYLoc $colZNegLoc ("inst_" + $sideRailA[0] + "_" + $i);
        instance -n ("inst_" + $sideRailB[0] + "_" + $i) $sideRailB[0]; move 0 $railYLoc $colZPosLoc ("inst_" + $sideRailB[0] + "_" + $i);
    }
    select -r "*fireEscape*"; doGroup 0 1 1; rename "grp_fireEscape";select -cl;
}

// ************************************************************************************************ //

/* UI */

proc buildingWizard() {
    
    // UI variables
    global string $winName = "buildingWin";
    global string $scrollLayout = "scrollLayoutWin";
    global string $columnLayout = "columnLayoutMain";
    global string $storiesNumField = "storiesNumberField";
    global string $levelFeaturesCB = "levelFeaturesCheckBox";
    global string $levelNameField = "levelNameField";
    global string $groundFloorHeightField = "groundFloorHeightField";
    global string $floorHeightField = "floorHeightField";
    global string $reinforcementDistField = "reinforcementDistField";
    global string $reinforcementScaleField = "reinforcementScaleField";
    global string $windowWidthField = "windowWidthField";;
    global string $windowHeightField = "windowHeightField";
    global string $windowDepthField = "windowDepthField";
    global string $windowHorPagField = "windowHorPagField";
    global string $eavesScaleField = "eavesScaleField";
    global string $cornerColScaleField = "cornerColScaleField";
    global string $roofRailingsHeightField = "roofRailingsHeightField";
    global string $roofRailingsDepthField = "roofRailingsDepthField";
    global string $roofEdgeDistanceField = "roofEdgeDistanceField";
    global string $reinforcementDistributionTypeList = "reinforcementDistributionTypeList";
    global string $reinforcementUnitsInClusterField = "reinforcementUnitsInClusterField";
    global string $reinforcementClustersNumberField = "reinforcementClustersNumberField";
    global string $reinforcementUnitWidthField = "reinforcementUnitWidthField";
    global string $reinforcementClusterIntervalField = "reinforcementClusterIntervalField";
    
    // Building assets variables
    global string $perimeterAsset[] = {"Please, update perimeter curve!"};
    global string $windowAsset[] = {"Please, update window!"};
    global string $windowBBoxAsset[]; $windowBBoxAsset[0] = "_";
    global string $cornerColAsset[] = {"Please, update corner column!"};
    global string $columnAsset[] = {"Please, update column!"};
    global string $reinforcementAsset[] = {"Please, update reinforcement!"};
    global string $eavesAsset[] = {"Please, update eaves!"};
    global string $antennaAsset[]; $antennaAsset[0] = "No Antennas!";
    global string $roofExitAsset[]; $roofExitAsset[0] = "No Roof Exit!";
    global string $roofACAsset[]; $roofACAsset[0] = "No Roof AC!";
    
    // Building structure variables
    global string $lvlName = "levelA";
    global int $floorsNum = 1;
    global float $floorHeight = 390;
    global float $groundFloorHeight = 780;
    global float $windowWidth = 300;
    global float $windowHeight = 120;
    global float $windowDepth = 20;
    global float $windowHorPag = 40;
    global float $windowVertPag = 60;
    global float $eavesScale = 1;
    global float $cornerColScale = 1;
    
    global float $roofRailingHeight = 120;
    global float $roofRailingDepth = 30;
    global float $roofEdgePag = 300;
    
    global string $reinforcementDistribution = "even";
    global int $reinforcementUnitsInCluster = 1;
    global int $reinforcementClustersNumber = 1;
    global float $reinforcementUnitWidth = 40;
    global float $reinforcementClusterInterval = 100;
    
    global int $groundFloorBool = 0;
    global int $cornerColumnsBool = 0;
    global int $reinforcementBool = 0;
    global int $eavesBool = 0;
    global int $roofRailingsBool = 0;
    
    // Building creation commands registration:
    global string $createWalls = "_";
    $createWalls = "wallsGen($perimeterAsset[0], $floorHeight, $lvlName);";
    
    global string $createWindows = "_";
    $createWindows = "windowPlacement($perimeterAsset[0], $groundFloorHeight, $floorHeight, $windowHorPag, $windowVertPag, $windowWidth, $windowHeight, $windowDepth, $lvlName);";
    
    global int $i = 1;
    
    if (`window -exists $winName`){
        deleteUI -window $winName;
    }
    
    window -title "Building Creation Wizard"
       -iconName "BuildWiz"
       -widthHeight 600 800 $winName;
    scrollLayout -horizontalScrollBarThickness 16 -verticalScrollBarThickness 16 $scrollLayout;
        // ------------------------------------------------------------------------------------------------------------------------
        // AREA 1: Assets Registration
        frameLayout -label "Assets Registration" -w 590 -fn "boldLabelFont" -bgc .2 .2 .2 -cll true -p $scrollLayout;
            columnLayout -adjustableColumn true -rowSpacing 2;
            //text -label "Assets Registration" -align "center" -h 20 -fn "boldLabelFont" -bgc .2 .2 .2;
                gridLayout -numberOfColumns 3 -cellWidthHeight 200 20;
                    // PERIMETER registration button
                    button -label "Update Perimeter" -command ("$perimeterAsset = `ls -sl -tr`; print \"Perimeter Updated\"");
                    // WINDOW registration button
                    button -label "Update Window" -command ("$windowAsset = `ls -sl -tr`; if (`objExists (\"BBox_\" + $windowAsset[0])`){$windowBBoxAsset[0] = (\"BBox_\" + $windowAsset[0]);}; print \"Window Updated\";");
                    // COLUMN registration button
                    //button -label "Update Column" -command ("$columnAsset = `ls -sl -tr`; print \"Column Updated\"");
                    // CORNER COLUMN registration button
                    button -label "Update Corner Col" -command ("$cornerColAsset = `ls -sl -tr`; print \"Corner Col Updated\"");
                    // REINFORCEMENT registration button
                    button -label "Update Reinforcement" -command ("$reinforcementAsset = `ls -sl -tr`; print \"Reinforcement Updated\"");
                    // EAVES registration button
                    button -label "Update Eaves" -command ("$eavesAsset = `ls -sl -tr`; print \"Eaves Updated\"");
                    // ROOF EXIT registration button
                    button -label "Update Roof Exit" -command ("$roofExitAsset = `ls -sl -tr`; print \"Roof Exit Updated\"");
                    // ROOF ANTENNA registration button
                    button -label "Update Antenna" -command ("$antennaAsset = `ls -sl -tr`; print \"Antenna Updated\"");
                    // ROOF AC registration button
                    button -label "Update Roof AC" -command ("$roofACAsset = `ls -sl -tr`; print \"Roof AC Updated\"");
                setParent..;
            setParent..;
        setParent..;
        separator -height 10 -style "in";
        
        // ------------------------------------------------------------------------------------------------------------------------
        // AREA 2: Structural Choices
        frameLayout -label "Features" -w 590 -fn "boldLabelFont" -bgc .2 .2 .2 -cll true;
            columnLayout -adjustableColumn true -rowSpacing 2;
                // Features checkboxes
                checkBoxGrp -numberOfCheckBoxes 4 -label "Features" -labelArray4 "Roof Railings" "Corner Columns" "Reinforcement" "Eaves" $levelFeaturesCB;
            setParent..;
        setParent..;
        separator -height 10 -style "in";
        
        // ------------------------------------------------------------------------------------------------------------------------
        // AREA 3: Parameters
        frameLayout -label "Parameters" -w 590 -fn "boldLabelFont" -bgc .2 .2 .2 -cll true;
            rowLayout -numberOfColumns 2 -columnWidth2 280 320 -adjustableColumn 2 -rowAttach 1 "top" 0 -rowAttach 2 "top" 0;
                columnLayout -adjustableColumn true -rowSpacing 2;
                    text -l "Level Options" -bgc .2 .2 .2;
                    // Level name field
                    textFieldGrp -label "Level Name" -tx "levelA" $levelNameField;
                    // Ground floor height
                    // floatSliderGrp -label "Ground Floor Height" -field true -minValue 210 -maxValue 1200 -v 780 -ss 10 $groundFloorHeightField;
                    // Floor height
                    floatSliderGrp -label "Floor Height" -field true -minValue 100 -maxValue 1200 -v 390 -ss 10 $floorHeightField;
                    // Number of floor in the building
                    intSliderGrp -label "Floors Number" -min 1 -max 100 -value 1 -step 1 -field true $storiesNumField;
                    // Eaves scale
                    floatSliderGrp -label "Eaves Scale" -field true -minValue 0 -maxValue 10 -v 1 -ss .1 $eavesScaleField;
                    // Corner Columns Scale
                    floatSliderGrp -label "Corner Columns Scale" -field true -minValue 0 -maxValue 10 -v 1 -ss .1 $cornerColScaleField;
                    // Roof Railing Height
                    floatSliderGrp -label "Roof Railing Height" -field true -minValue 0 -maxValue 200 -v 120 -ss .1 $roofRailingsHeightField;
                    // Roof Railing Depth
                    floatSliderGrp -label "Roof Railing Depth" -field true -minValue 0 -maxValue 200 -v 30 -ss .1 $roofRailingsDepthField;
                    // Roof Edge Distance
                    floatSliderGrp -label "Roof Edge Distance" -field true -minValue 0 -maxValue 5000 -v 300 -ss .1 $roofEdgeDistanceField;
                setParent..;
                columnLayout -adjustableColumn true -rowSpacing 2;
                    text -l "Features Options" -bgc .2 .2 .2;
                    // Window Width
                    floatSliderGrp -label "Window Width" -field true -minValue 0 -maxValue 800 -v 300 -ss 10 $windowWidthField;
                    // Window Height
                    floatSliderGrp -label "Window Height" -field true -minValue 0 -maxValue 1000 -v 120 -ss 10 $windowHeightField;
                    // Window Depth
                    floatSliderGrp -label "Window Depth" -field true -minValue -200 -maxValue 200 -v 20 -ss 10 $windowDepthField;
                    // Window Horisontal Paggination
                    floatSliderGrp -label "Window Hor Pag" -field true -minValue 0 -maxValue 200 -v 40 -ss 10 $windowHorPagField;
                    // Reinforcement Distribution
                    optionMenu -label "Reinforcement Distribution" -changeCommand "print #1; $reinforcementDistribution = (\"#1\");" $reinforcementDistributionTypeList;
                        menuItem -label "even";
                        menuItem -label "betweenWindows";
                        menuItem -label "middle";
                    // Reinforcement Units in Cluster
                    intSliderGrp -label "Reinforcement Units in Cluster" -field true -minValue 1 -maxValue 10 -v 1 -ss 1 $reinforcementUnitsInClusterField;
                    // Reinforcement Clusters Number
                    intSliderGrp -label "Reinforcement Clusters Number" -field true -minValue 1 -maxValue 10 -v 1 -ss 1 $reinforcementClustersNumberField;
                    // Reinforcement Unit Width
                    floatSliderGrp -label "Reinforcement Unit Width" -field true -minValue 0 -maxValue 800 -v 40 -ss .1 $reinforcementUnitWidthField;
                    // Reinforcement Cluster Interval
                    floatSliderGrp -label "Reinforcement Cluster Interval" -field true -minValue 0 -maxValue 800 -v 100 -ss .1 $reinforcementClusterIntervalField;
                setParent..;
            setParent..;
        setParent..;
         
        separator -height 10 -style "in";
        
        // ------------------------------------------------------------------------------------------------------------------------
        // AREA 4: Generating
        // Generate a building
        frameLayout -label "Generation" -w 590 -fn "boldLabelFont" -bgc .2 .2 .2 -cll true;
            columnLayout -adjustableColumn true -rowSpacing 2;
            
            button -label "Progress Check!" -command ("print $reinforcementDistribution;");
            button -label "Generate Walls" -command ("if ($perimeterAsset[0] == \"Please, update perimeter curve!\"){print \"Please, update perimeter curve!\";} else {$lvlName = `textFieldGrp -q -tx $levelNameField`; $floorHeight = `floatSliderGrp -q -v $floorHeightField`; wallsGen($perimeterAsset[0], $floorHeight, $lvlName);}");
            
            button -label "Generate Windows" -command ("if ($perimeterAsset[0] == \"Please, update window!\"){print \"Please, update window!\";} else {$lvlName = `textFieldGrp -q -tx $levelNameField`; $floorHeight = `floatSliderGrp -q -v $floorHeightField`; $windowWidth = `floatSliderGrp -q -v $windowWidthField`; $windowHeight = `floatSliderGrp -q -v $windowHeightField`; $windowDepth = `floatSliderGrp -q -v $windowDepthField`; $windowHorPag = `floatSliderGrp -q -v $windowHorPagField`; " + $createWindows + " select -r \"loc_window*\"; $winLocators = `ls -sl -tr`; select -cl; instAtLocators($winLocators, $windowAsset[0], $lvlName); if ($windowBBoxAsset[0] != \"_\"){bboxPlacement($windowAsset[0], $windowBBoxAsset[0], $lvlName);} delete \"loc_window*\";}");
                                                       
            button -label "Press In Windows" -command ("$lvlName = `textFieldGrp -q -tx $levelNameField`; $windowDepth = `floatSliderGrp -q -v $windowDepthField`; windowsCutOut(($lvlName + \"_wall_\"), ($lvlName + \"_\" + $windowAsset[0] + \"_\"), $windowDepth, $windowBBoxAsset[0], $lvlName);");
            
            button -label "Generate Corner Columns" -command ("if ((`checkBoxGrp -q -v2 $levelFeaturesCB`) > 0){$lvlName = `textFieldGrp -q -tx $levelNameField`; cornerColumnsInst($perimeterAsset[0], $cornerColAsset[0], $lvlName);} else {print \"No Columns...\";}");
            
            button -label "Generate Reinforcements" -command ("if ((`checkBoxGrp -q -v3 $levelFeaturesCB`) > 0){$reinforcementDistribution = `optionMenu -q -v $reinforcementDistributionTypeList`; $lvlName = `textFieldGrp -q -tx $levelNameField`; $reinforcementUnitsInCluster = `intSliderGrp -q -v $reinforcementUnitsInClusterField`; $reinforcementClustersNumber = `intSliderGrp -q -v $reinforcementClustersNumberField`; $reinforcementUnitWidth = `floatSliderGrp -q -v $reinforcementUnitWidthField`; $reinforcementClusterInterval = `floatSliderGrp -q -v $reinforcementClusterIntervalField`; reinforcementsPlacement($reinforcementDistribution, $lvlName, $perimeterAsset[0], $reinforcementAsset[0], $windowAsset[0], $reinforcementUnitsInCluster, $reinforcementClustersNumber, $reinforcementUnitWidth, $reinforcementClusterInterval); select -r \"loc_reinforcement*\"; $reinforcementLocators = `ls -sl -tr`; select -cl; instAtLocators($reinforcementLocators, $reinforcementAsset[0], $lvlName); delete \"loc_reinforcement*\";} else {print \"No Reinforcements...\";}");
            
            button -label "Generate Eaves" -command ("if ((`checkBoxGrp -q -v4 $levelFeaturesCB`) > 0){$lvlName = `textFieldGrp -q -tx $levelNameField`; extrudeEaves($perimeterAsset[0], $eavesAsset[0], $lvlName);} else {print \"No Eaves...\";}");
                                                                                                      
            button -label "Group Level" -command ("$lvlName = `textFieldGrp -q -tx $levelNameField`; group -em -n (\"grp_\" + $lvlName); parent ($lvlName + \"*\") (\"grp_\" + $lvlName); select -cl;");
            
            button -label "Build Height" -command ("$lvlName = `textFieldGrp -q -tx $levelNameField`; $floorHeight = `floatSliderGrp -q -v $floorHeightField`; $floorsNum = `intSliderGrp -q -v $storiesNumField`; instanceLevel($lvlName, $floorHeight, $floorsNum); if (`objExists \"grp_building\"`){parent (\"grp_\" + $lvlName + \"*\") \"grp_building\";} else {group -em -n \"grp_building\"; parent (\"grp_\" + $lvlName + \"*\") \"grp_building\";}");
            
            button -label "Generate Roof" -command ("$floorHeight = `floatSliderGrp -q -v $floorHeightField`; $floorsNum = `intSliderGrp -q -v $storiesNumField`; $lvlName = `textFieldGrp -q -tx $levelNameField`; roofGen($perimeterAsset[0], $floorHeight, $floorsNum, $lvlName); parent ($lvlName + \"_roof_0\") \"grp_building\"; select -cl;");
            
            button -label "Populate Roof" -command ("$roofRailingsBool = `checkBoxGrp -q -v1 $levelFeaturesCB`; $roofRailingHeight = `floatSliderGrp -q -v $roofRailingsHeightField`; $roofRailingDepth = `floatSliderGrp -q -v $roofRailingsDepthField`; $roofEdgePag = `floatSliderGrp -q -v $roofEdgeDistanceField`; $lvlName = `textFieldGrp -q -text $levelNameField`; roofSetDressing($antennaAsset[0], $roofACAsset[0], $roofExitAsset[0], $roofRailingsBool, $roofRailingHeight, $roofRailingDepth, $lvlName, $roofEdgePag);");
            
            button -label "Fire Escape" -command ("$lvlName = `textFieldGrp -q -tx $levelNameField`; $floorsNum = `intSliderGrp -q -v $storiesNumField`; $floorHeight = `floatSliderGrp -q -v $floorHeightField`; fireEscapeLadder($lvlName, $floorsNum, $windowAsset[0], $floorHeight, 2, 25, 120, 25);");
    
            button -label "Close" -command ("deleteUI -window " + $winName);
        setParent..;
    setParent $winName;
    showWindow $winName;   
}

buildingWizard;



